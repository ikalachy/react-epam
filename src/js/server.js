import path from 'path'
import Express from 'express'
import { ChunkExtractor } from '@loadable/server'

import React from 'react'
import thunk from 'redux-thunk'
import { Provider } from 'react-redux'
import { StaticRouter } from "react-router-dom";
import { renderToString } from 'react-dom/server'
import { createStore, applyMiddleware, compose } from 'redux'
import "core-js/stable";
import "regenerator-runtime/runtime";

import App from './App'
import rootReducer from './reducers'

import 'bootstrap/dist/css/bootstrap.min.css';
import fetch from "isomorphic-fetch";


const app = Express()
const port = 8080


app.get(/\.(js|css|map|ico|png|jpg|gif|jpeg)$/, Express.static(path.resolve(__dirname, '../../build')));

// This is fired every time the server side receives a request
app.use('*', handleRender)

// We are going to fill these out in the sections to follow
function handleRender(req, res) {
  // Create a new Redux store instance
  console.log()
  const movies = fetchInitialMovies()


  Promise.resolve(movies).then((values) => {


    const initialState = {
      movies: values,
      visibilityFilter: {
        filter: 'SHOW_ALL',
        value: ''
      },
      sort: {
        sortBy: 'releaseDate',
        order: 'ASC'
      },
      modal: {
        modalType: null,
        modalProps: {
          open: false
        }
      }
    }


    const store = createStore(rootReducer, initialState, applyMiddleware(thunk))
    //store.dispatch(fetchAllMovies)

    console.log(`handleRender() uri: ${req.originalUrl}`)
    console.log(`handleRender() store: ${JSON.stringify(store)}`)
    // Render the component to a string
    // This is the stats file generated by webpack loadable plugin
    const statsFile = path.resolve(__dirname, '../../build/loadable-stats.json')
    const extractor = new ChunkExtractor({ statsFile,  publicPath: '/', entrypoints: ["client"] })

    // Wrap your application using "collectChunks"
    const jsx = extractor.collectChunks(
      <Provider store={store}>
        <StaticRouter location={req.originalUrl} context={context}>
          <App />
        </StaticRouter>
      </Provider>)

    const context = {};
    const html = renderToString(jsx)

    // You can now collect your script tags
    const scriptTags = extractor.getScriptTags() // or extractor.getScriptElements();
    // You can also collect your "preload/prefetch" links
    const linkTags = extractor.getLinkTags() // or extractor.getLinkElements();
    // And you can even collect your style tags (if you use "mini-css-extract-plugin")
    const styleTags = extractor.getStyleTags() // or extractor.getStyleElements();


    if (context.originalUrl) {
      // Somewhere a `<Redirect>` was rendered
      redirect(301, context.originalUrl);
    } else {
      // we're good, send the response


      // Grab the initial state from our Redux store
      const preloadedState = store.getState()

      // Send the rendered page back to the client
      const result = renderFullPage(html, preloadedState, styleTags, linkTags, scriptTags)
      res.send(result)
    }
  }
  )

}

function renderFullPage(html, preloadedState, styleTags, linkTags, scriptTags) {
  const state = JSON.stringify(preloadedState).replace(/</g, '\\u003c')
  const result = `
  <!doctype html>
  <html>
    <head>
      ${styleTags}
      ${linkTags}
      <title>NETFLIXRoulette Movie App</title>
    </head>
    <body style="background-color:#555">
      <div id="root">${html}</div>
      <script>
        // WARNING: See the following for security issues around embedding JSON in HTML:
        // https://redux.js.org/recipes/server-rendering/#security-considerations
        window.__PRELOADED_STATE__ = ${state}
      </script>
      ${scriptTags}
    </body>
  </html>
  `

  return result
}


async function fetchInitialMovies() {
  const movies = await fetch("https://600d74baf979dd001745cba7.mockapi.io/api/v1/movies").then(res => res.json()).catch( er=> [] )
  //console.log(`fetch ${JSON.stringify(movies)}`)

  return movies
}


app.listen(port)